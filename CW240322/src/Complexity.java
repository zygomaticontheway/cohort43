public class Complexity {
/*
Ведение в анализ сложности алгоритмов

Сложность алгоритмов - насколько быстро работает код.

Алгоритм (простым языком) - вычисления, которые проводит программа.
Алгоритм - последовательность шагов, представляющая собой исключительно вычисления без учета особенностей
реализации "комп. железа", на котором она работает.

Анализ сложности - дает понять, как быстро будет работать программа, когда она совершает вычисления на разных объемах данных.

 */

    public static void main(String[] args) {

    }

    //Найти максимальный элемент массива
    public static int findMaxElt (int[] ints, int n) {
        int max = ints [0]; // 2 действия (инструкции) которые происходят всегда

        for (int i = 0; i < n; i++){ //2 действия происходят до запуска for: инициализация i, проверка условия окончания цикла i<n + 1 i++ + 1 снова проверка i<n
            if (ints [i] > max){
                max = ints[i];
            }
        }
        return max;
    }
        /*
       f(n) = 4 (действия до начала цикла) + 2n (действия в цикле) - необходимое алгоритму количество инструкций для цикла for с пустым телом
       f(n) = 4 + 2n

       {1,2,3,4}
       {4,3,2,1}

       В теории алгоритмов рассматриваются наихудшие сценарии, т.е. для данной задачи это упорядоченный по возрастанию массив,
       где макс значение переписывается для каждой итерации

       f(n) = 4 + 2n + 4n = 6n + 4

       Когда n сильно растет, константы можно не учитывать (отбрасываем 4 и 6?), они не важны:
       f(n) = 6n
       f(n) = n
       Асимптотическое поведение для функции f(n) = 6n + 4 будет f(n) = n

    //Примеры:
       f(n) = 8n + 45 -> f(n) = n

       f(n) = 456 -> f(n) = 1

       f(n) = n^2 + 4n + 432 -> f(n) n^2 //4n растет меньше, чем n^2 и имеет меньший вклад, значит не влияет и отбрасывается

       f(n) = n^3 + 2000n + 300 -> f(n) = n^3

    //Нотация "большое О"
        O(f(n)) = O(n) //упрощение записи
        f(n) = 1 -> O(1) - алгоритм с константным временем и его сложность равна 1
        f(n) = n -> O(n) - алгоритм с константным временем и его сложность равна n
        f(n) = n^2 -> O(n^2) - алгоритм с константным временем и его сложность равна n^2
        f(n) = n^3 -> O(n^3) - алгоритм с константным временем и его сложность равна n^3
        O(log n) -

        2^x = 1024
        2^10 = 1024
        логарифм 1024 - это слепень, в которую нужно возвести 2, чтобы получить 1024
        log (1024) = 10 //2^10 = 1024
        log (64) = 64 //2^6 = 64

    //Правило
        Если циклов нет, то сложность - константа 1
        Если 1 цикл есть, то n
        Если цикл в цикле, то n^2 - и это плохо и нужно таких решений избегать
        ...
         */
}
